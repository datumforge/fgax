{{/* gotype: entgo.io/ent/entc/gen.Graph */}}

{{ define "authzChecks" }}
// Code generated by entfga, DO NOT EDIT.

    {{ $pkg := base $.Config.Package }}
    {{ template "header" $ }}

{{/* Add immports so the correct privacy package is imported */}}
import (
	"context"

	"github.com/99designs/gqlgen/graphql"
	"entgo.io/ent/privacy"
	"github.com/datumforge/fgax"
)

    {{ range $n := $.Nodes }}
    {{ $name := $n.Name }}
        {{ $mutator := $n.MutationName }}
        {{ $querier := $n.QueryName }}

        {{/* Only include nodes with the Authz check anntoation. See: Annotations.Name */}}
        {{ if $n.Annotations.Authz }}

        {{ $objectType := extractObjectType $n.Annotations.Authz.ObjectType }}
        {{ $idField := extractIDField $n.Annotations.Authz.IDField  }}
        {{ $nillable := extractNillableIDField $n.Annotations.Authz.NillableIDField  }}

        func (q *{{ $querier }}) CheckAccess(ctx context.Context) error {
            gCtx := graphql.GetFieldContext(ctx)

            if gCtx != nil {
                ac := fgax.AccessCheck{
                    Relation: fgax.CanView,
                    ObjectType:  "{{ $objectType | ToLower }}",
                }

                // check id from graphql arg context
                // when all objects are requested, the interceptor will check object access
                // check the where input first
                whereArg := gCtx.Args["where"]
                if whereArg != nil {
                    where, ok := whereArg.(*{{ $name }}WhereInput)
                    if ok && where != nil && where.{{ $idField }} != nil {
                        ac.ObjectID = *where.{{ $idField }}
                    }
                }

                // if that doesn't work, check for the id in the args
                if ac.ObjectID == "" {
                    ac.ObjectID, _ = gCtx.Args["{{ $idField | ToLower }}"].(string)
                }
            
                // if we still don't have an object id, run the query and grab the object ID 
                // from the result
                // this happens on join tables where we have the join ID (for updates and deletes)
                // and not the actual object id
                if ac.ObjectID == "" && "id" !=  "{{ $idField | ToLower }}" {
                    // allow this query to run
                    reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
                    ob, err := q.Clone().Only(reqCtx)
                    if err != nil {
                        return privacy.Allowf("nil request, bypassing auth check")
                    }
                    
                    ac.ObjectID = ob.{{ $idField }}
                }

                // request is for a list objects, will get filtered in interceptors
                if ac.ObjectID == ""  {
                    return privacy.Allowf("nil request, bypassing auth check")
                }

                var err error
                ac.UserID, err = auth.GetUserIDFromContext(ctx)
                if err != nil {
                    return err
                }

                
                access, err := q.Authz.CheckAccess(ctx, ac)
                if err != nil {
                    return privacy.Skipf("unable to check access, %s", err.Error())
                }

                if access {
                    return privacy.Allow
                }
            }

            // Skip to the next privacy rule (equivalent to return nil)
            return privacy.Skip
        }

        func (m *{{ $mutator }}) CheckAccessForEdit(ctx context.Context) error {
            ac := fgax.AccessCheck{
                Relation: fgax.CanEdit,
                ObjectType:  "{{ $objectType | ToLower }}",
            }

            gCtx := graphql.GetFieldContext(ctx)

            {{ if hasCreateID $n.Annotations.Authz.IDField }}
            // get the input from the context
            gInput := gCtx.Args["input"]

            // check if the input is a Create{{ $name }}Input
            input, ok := gInput.(Create{{ $name }}Input)
            if ok {
                {{- if $nillable }}
                ac.ObjectID = *input.{{ $idField }}
                {{ else }}
                ac.ObjectID = input.{{ $idField }}
                {{ end }}
            } 
            {{ end }}

            // check the id from the args
            if ac.ObjectID == "" {
                ac.ObjectID, _ = gCtx.Args["{{ $idField | ToLower }}"].(string)
            }

            // if this is still empty, we need to query the object to get the object id
            // this happens on join tables where we have the join ID (for updates and deletes)
            if ac.ObjectID == "" && "id" !=  "{{ $idField | ToLower }}" {
                id, ok := gCtx.Args["id"].(string)
                if ok {
                    // allow this query to run
                    reqCtx := privacy.DecisionContext(ctx, privacy.Allow)
                    ob, err := m.Client().{{ $name }}.Query().Where({{ $name | ToLower }}.ID(id)).Only(reqCtx)
                    if err != nil {
                        return privacy.Allowf("nil request, bypassing auth check")
                    }

                    ac.ObjectID = ob.{{ $idField }}
                }
            }

            // request is for a list objects, will get filtered in interceptors
            if ac.ObjectID == ""  {
                return privacy.Allowf("nil request, bypassing auth check")
            }

            m.Logger.Debugw("checking mutation access")

            var err error
            ac.UserID, err = auth.GetUserIDFromContext(ctx)
            if err != nil {
                return err
            }

            m.Logger.Infow("checking relationship tuples", "relation", ac.Relation, "object_id", ac.ObjectID)

            access, err := m.Authz.CheckAccess(ctx, ac)
            if err != nil {
                return privacy.Skipf("unable to check access, %s", err.Error())
            }

            if access {
                m.Logger.Debugw("access allowed", "relation", ac.Relation, "object_id", ac.ObjectID)

                return privacy.Allow
            }

            // deny if it was a mutation is not allowed
            return privacy.Deny
        }

        func (m *{{ $mutator }}) CheckAccessForDelete(ctx context.Context) error {
            ac := fgax.AccessCheck{
                Relation: fgax.CanDelete,
                ObjectType:  "{{ $objectType | ToLower }}",
            }

            gCtx := graphql.GetFieldContext(ctx)

            var ok bool
            ac.ObjectID, ok = gCtx.Args["id"].(string)
            if !ok {
                return privacy.Allowf("nil request, bypassing auth check")
            }

            m.Logger.Debugw("checking mutation access")

            var err error
            ac.UserID, err = auth.GetUserIDFromContext(ctx)
            if err != nil {
                return err
            }

            m.Logger.Infow("checking relationship tuples", "relation", ac.Relation, "object_id", ac.ObjectID)

            access, err := m.Authz.CheckAccess(ctx, ac)
            if err != nil {
                return privacy.Skipf("unable to check access, %s", err.Error())
            }

            if access {
                m.Logger.Debugw("access allowed", "relation", ac.Relation, "object_id", ac.ObjectID)

                return privacy.Allow
            }

            // deny if it was a mutation is not allowed
            return privacy.Deny
        }
    {{ end }}
    {{ end }}
{{ end }}