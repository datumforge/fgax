{{/* gotype: entgo.io/ent/entc/gen.Graph */}}

{{ define "authFromMutation" }}
// Code generated by entfga, DO NOT EDIT.

    {{ $pkg := base $.Config.Package }}
    {{ template "header" $ }}

    {{/* Add Check for Soft Delete See: AuthzConfig.SoftDeletes */}}
    {{ $softDeletes := $.Annotations.AuthzConfig.SoftDeletes }}

    {{ range $n := $.Nodes }}
    {{ $name := $n.Name }}
        {{ $mutator := $n.MutationName }}
        {{/* Only include nodes with the Autz anntoation. See: Annotation.Name */}}
        {{ if $n.Annotations.Authz }}
        {{ $objectType := extractObjectType $n.Annotations.Authz.ObjectType }}
        func (m *{{ $mutator }}) CreateTuplesFromCreate(ctx context.Context) error {
            // Get fields for tuple creation
            userID, _ := m.UserID()
            objectID, _ := m.{{ $objectType | ToUpperCamel }}ID()
            role, _ := m.Role()

            // get tuple key 
            tuple, err := fga.GetTupleKey(userID, "user", objectID, "{{ $objectType | ToLower }}" , role.String())
            if err != nil {
                return err
            }

            if _, err := m.Authz.WriteTupleKeys(ctx, []fga.TupleKey{tuple}, nil); err != nil {
                m.Logger.Errorw("failed to create relationship tuple", "error", err)

                return err
            }

            m.Logger.Debugw("created relationship tuples", "relation", role, "object", tuple.Object)

            return nil
        }

        func (m *{{ $mutator }}) CreateTuplesFromUpdate(ctx context.Context) error {
            {{- if $softDeletes }}
            // check for soft delete operation and delete instead
            if entx.CheckIsSoftDelete(ctx) {
                return m.CreateTuplesFromDelete(ctx)
            }
            {{- end }}

            // get ids that will be updated
            ids, err := m.IDs(ctx)
            if err != nil {
                return err
            }

            var (
                writes  []fga.TupleKey
                deletes []fga.TupleKey
            )

            oldRole, err := m.OldRole(ctx)
            if err != nil {
                return err
            }

            newRole, exists := m.Role()
            if !exists {
                return entfga.ErrMissingRole
            }

            if oldRole == newRole {
                m.Logger.Debugw("nothing to update, roles are the same", "old_role", oldRole, "new_role", newRole)

                return nil
            }

            // User the IDs of the memberships and delete all related tuples
            for _, id := range ids {
                member, err := m.Client().{{ $name }}.Get(ctx, id)
                if err != nil {
                    return err
                }

                d, err := fga.GetTupleKey(member.UserID, "user", member.{{ $objectType | ToUpperCamel }}ID, "{{ $objectType | ToLower }}", oldRole.String())
                if err != nil {
                    return err
                }

                deletes = append(deletes, d)

                w, err := fga.GetTupleKey(member.UserID, "user", member.{{ $objectType | ToUpperCamel }}ID, "{{ $objectType | ToLower }}", newRole.String())
                if err != nil {
                    return err
                }

                writes = append(writes, w)

                if len(writes) == 0 && len(deletes) == 0 {
                    m.Logger.Debugw("no relationships to create or delete")

                    return nil
                }

                if _, err := m.Authz.WriteTupleKeys(ctx, writes, deletes); err != nil {
                    m.Logger.Errorw("failed to update relationship tuple", "error", err)

                    return err
                }
            }

            return nil
        }

        func (m *{{ $mutator }}) CreateTuplesFromDelete(ctx context.Context) error {
            {{- if $softDeletes }}
            // check for soft delete operation and skip so it happens on update
            if entx.CheckIsSoftDelete(ctx) {
                return nil 
            }
            {{- end }} 

            // get ids that will be deleted
            ids, err := m.IDs(ctx)
            if err != nil {
                return err
            }

            tuples := []fga.TupleKey{}

            // User the IDs of the memberships and delete all related tuples
            for _, id := range ids {
                // this wont work with soft deletes
                members, err := m.Client().{{ $name }}.Get(ctx, id)
                if err != nil {
                    return err
                }

                t, err := fga.GetTupleKey(members.UserID, "user", members.{{ $objectType | ToUpperCamel }}ID, "{{ $objectType | ToLower }}", members.Role.String())
                if err != nil {
                    return err
                }

                tuples = append(tuples, t)
            }

            if len(tuples) > 0 {
                if _, err := m.Authz.WriteTupleKeys(ctx, nil, tuples); err != nil {
                    m.Logger.Errorw("failed to delete relationship tuple", "error", err)

                    return err
                }

                m.Logger.Debugw("deleted relationship tuples")
            }


            return nil
        }
    {{ end }}
    {{ end }}
{{ end }}