// Code generated by entfga, DO NOT EDIT.

// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"

	"entgo.io/ent/privacy"
	"github.com/99designs/gqlgen/graphql"
	"github.com/datumforge/fgax"
	"github.com/datumforge/fgax/entfga/_examples/basic/auth"
)

func (q *OrgMembershipQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx != nil {
		ac := fgax.AccessCheck{
			Relation: fgax.CanView,
		}

		// check id from graphql arg context
		// when all objects are requested, the interceptor will check object access
		whereArg := gCtx.Args["where"]
		if whereArg != nil {
			where, ok := whereArg.(*OrgMembershipWhereInput)
			if ok && where != nil && where.OrganizationID != nil {
				ac.ObjectID = *where.OrganizationID
			}
		}

		if ac.ObjectID == "" {
			var ok bool
			ac.ObjectID, ok = gCtx.Args["id"].(string)
			if !ok {
				return privacy.Allowf("nil request, bypassing auth check")
			}
		}

		var err error
		ac.UserID, err = auth.GetUserIDFromContext(ctx)
		if err != nil {
			return err
		}

		access, err := q.Authz.CheckAccess(ctx, ac)
		if err != nil {
			return privacy.Skipf("unable to check access, %s", err.Error())
		}

		if access {
			return privacy.Allow
		}
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *OrgMembershipMutation) CheckAccessForEdit(ctx context.Context) error {
	ac := fgax.AccessCheck{
		Relation:   fgax.CanEdit,
		ObjectType: "organization",
	}

	gCtx := graphql.GetFieldContext(ctx)

	// get the input from the context
	gInput := gCtx.Args["input"]

	// check if the input is a CreateOrgMembershipInput
	input, ok := gInput.(CreateOrgMembershipInput)
	if ok {
		ac.ObjectID = input.OrganizationID
	}

	if ac.ObjectID == "" {
		var ok bool
		ac.ObjectID, ok = gCtx.Args["id"].(string)
		if !ok {
			return privacy.Allowf("nil request, bypassing auth check")
		}
	}

	m.Logger.Debugw("checking mutation access")

	var err error
	ac.UserID, err = auth.GetUserIDFromContext(ctx)
	if err != nil {
		return err
	}

	m.Logger.Infow("checking relationship tuples", "relation", ac.Relation, "object_id", ac.ObjectID)

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err != nil {
		return privacy.Skipf("unable to check access, %s", err.Error())
	}

	if access {
		m.Logger.Debugw("access allowed", "relation", ac.Relation, "object_id", ac.ObjectID)

		return privacy.Allow
	}

	// deny if it was a mutation is not allowed
	return privacy.Deny
}

func (m *OrgMembershipMutation) CheckAccessForDelete(ctx context.Context) error {
	ac := fgax.AccessCheck{
		Relation:   fgax.CanDelete,
		ObjectType: "organization",
	}

	gCtx := graphql.GetFieldContext(ctx)

	var ok bool
	ac.ObjectID, ok = gCtx.Args["id"].(string)
	if !ok {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	m.Logger.Debugw("checking mutation access")

	var err error
	ac.UserID, err = auth.GetUserIDFromContext(ctx)
	if err != nil {
		return err
	}

	m.Logger.Infow("checking relationship tuples", "relation", ac.Relation, "object_id", ac.ObjectID)

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err != nil {
		return privacy.Skipf("unable to check access, %s", err.Error())
	}

	if access {
		m.Logger.Debugw("access allowed", "relation", ac.Relation, "object_id", ac.ObjectID)

		return privacy.Allow
	}

	// deny if it was a mutation is not allowed
	return privacy.Deny
}

func (q *OrganizationQuery) CheckAccess(ctx context.Context) error {
	gCtx := graphql.GetFieldContext(ctx)

	if gCtx != nil {
		ac := fgax.AccessCheck{
			Relation: fgax.CanView,
		}

		// check id from graphql arg context
		// when all objects are requested, the interceptor will check object access
		whereArg := gCtx.Args["where"]
		if whereArg != nil {
			where, ok := whereArg.(*OrganizationWhereInput)
			if ok && where != nil && where.ID != nil {
				ac.ObjectID = *where.ID
			}
		}

		if ac.ObjectID == "" {
			var ok bool
			ac.ObjectID, ok = gCtx.Args["id"].(string)
			if !ok {
				return privacy.Allowf("nil request, bypassing auth check")
			}
		}

		var err error
		ac.UserID, err = auth.GetUserIDFromContext(ctx)
		if err != nil {
			return err
		}

		access, err := q.Authz.CheckAccess(ctx, ac)
		if err != nil {
			return privacy.Skipf("unable to check access, %s", err.Error())
		}

		if access {
			return privacy.Allow
		}
	}

	// Skip to the next privacy rule (equivalent to return nil)
	return privacy.Skip
}

func (m *OrganizationMutation) CheckAccessForEdit(ctx context.Context) error {
	ac := fgax.AccessCheck{
		Relation:   fgax.CanEdit,
		ObjectType: "organization",
	}

	gCtx := graphql.GetFieldContext(ctx)

	if ac.ObjectID == "" {
		var ok bool
		ac.ObjectID, ok = gCtx.Args["id"].(string)
		if !ok {
			return privacy.Allowf("nil request, bypassing auth check")
		}
	}

	m.Logger.Debugw("checking mutation access")

	var err error
	ac.UserID, err = auth.GetUserIDFromContext(ctx)
	if err != nil {
		return err
	}

	m.Logger.Infow("checking relationship tuples", "relation", ac.Relation, "object_id", ac.ObjectID)

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err != nil {
		return privacy.Skipf("unable to check access, %s", err.Error())
	}

	if access {
		m.Logger.Debugw("access allowed", "relation", ac.Relation, "object_id", ac.ObjectID)

		return privacy.Allow
	}

	// deny if it was a mutation is not allowed
	return privacy.Deny
}

func (m *OrganizationMutation) CheckAccessForDelete(ctx context.Context) error {
	ac := fgax.AccessCheck{
		Relation:   fgax.CanDelete,
		ObjectType: "organization",
	}

	gCtx := graphql.GetFieldContext(ctx)

	var ok bool
	ac.ObjectID, ok = gCtx.Args["id"].(string)
	if !ok {
		return privacy.Allowf("nil request, bypassing auth check")
	}

	m.Logger.Debugw("checking mutation access")

	var err error
	ac.UserID, err = auth.GetUserIDFromContext(ctx)
	if err != nil {
		return err
	}

	m.Logger.Infow("checking relationship tuples", "relation", ac.Relation, "object_id", ac.ObjectID)

	access, err := m.Authz.CheckAccess(ctx, ac)
	if err != nil {
		return privacy.Skipf("unable to check access, %s", err.Error())
	}

	if access {
		m.Logger.Debugw("access allowed", "relation", ac.Relation, "object_id", ac.ObjectID)

		return privacy.Allow
	}

	// deny if it was a mutation is not allowed
	return privacy.Deny
}
